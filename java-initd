#!/bin/bash

###
#
# Spawns process in own session as specified user (daemonize).
#
# Stopping will be done in up to three fazes:
#  1. Use STOP_COMMAND if defined than wait for STOP_WAIT until process exits
#  2. Send SIGTERM and wait for STOP_WAIT until process exits
#  3. Send SIGKILL if allowed by ALLOW_KILL and wait for STOP_WAIT until process exits
#
# Note that stop process will send signals to all processes that start process has spawned.
# Note that locking mechanism is based on file locking (flock).
#
# Following variables needs to be defined in sysconfig:
#
# APPLICATION_NAME		name of the application for display purposes (optional)
# WORKING_DIRECTORY		directory to change into before executing start/stop
# PID_FILE				file where pid will be stored
# LOG_FILE				file to redirect process output to
# RUN_USER				user that will be used to run start/stop/status commands
# START_COMMAND			command used to start the process
# STOP_COMMAND			command used to stop the process; %PID substring will be replaced with process PID (optional)
# STOP_WAIT				time in seconds to wait for stop command effect
# ALLOW_KILL			if true SIGKILL may be sent to process if it refuses to stop
#

## Functions

error() {
	echo "$1!" 1>&2
	exit $2
}

ok() {
	if [ -x /etc/rc.d/init.d/functions ]; then
		echo_success
		echo $1
	else
		echo "$1 [  OK  ]"
	fi
	exit $2
}

fail() {
	if [ -x /etc/rc.d/init.d/functions ]; then
		echo_failure
		echo $1
	else
		echo "$1 [  FAILED  ]"
	fi
	exit $2
}

clean_lock() {
	[[ -w "$INITD_LOCK" ]] && rm -f "$INITD_LOCK"
}

lock_initd() {
	[[ -f "$INITD_LOCK" ]] || touch "$INITD_LOCK" || error "cannot touch init script lock file '$INITD_LOCK'" 2
	exec 200>>"$INITD_LOCK"
	flock -n 200
}

need_initd_lock() {
	lock_initd || error "script already running" 2
	# clean_lock on termination
	trap "clean_lock" 0 1 2 3 6 9 14 15
}

close_fds() {
	# We close all inherited FDs
	# This is important so we don't hold open file or sockets from calling process
	for I in {3..255}; do eval "exec $I>&-"; done
}

aquire_pid_lock() {
	[[ -f "$PID_FILE" ]] || touch "$PID_FILE" || error "cannot touch pid file '$PID_FILE'" 2
	exec 201>>"$PID_FILE"
	flock -n 201
	RET=$?
	[[ $RET > 0 ]] && release_pid_lock
	return $RET
}

release_pid_lock() {
	exec 201<&-
}

run_as() {
	local RUN_USER="$1"
	local COMMAND="$2"

	if [[ "$USER" == "$RUN_USER" || -z "$RUN_USER" ]]; then
		# We're already the $RUN_AS_USER so just exec the script.
		/bin/bash -l -c "$COMMAND"
	else
		COMPLETE_COMMAND="(${NOHUP}$COMPLETE_COMMAND')$STDOUT_REDIR"
		[[ "$USER" == "root" ]] || error "cannot run command '$COMMAND' as user '$RUN_USER': need to be root" 99
		su - $RUN_USER -c "$COMMAND"
	fi
}

daemonize() {
	local RUN_USER="$1"
	local COMMAND="$2"
	local LOG_FILE="$3"
	local PID_FILE="$4"

	# Here we make new process with new session (setsid) and run it with closed STDIN and this init script lock file fd
	run_as "$RUN_USER" "setsid bash -c '( $COMMAND ) 0<&- 200<&- 1>>\"$LOG_FILE\" 2>&1 & eval \"echo \$! > '$PID_FILE'\"'"
}

pids() {
	run_as "$RUN_USER" "fuser /tmp/test.pid 2>/dev/null | sed 's, *,,'"
}

pid() {
	pids | cut -d ' ' -f 1
}

pids_send_signal() {
	local SIGNAL="$1"
	run_as "$RUN_USER" "fuser /tmp/test.pid -s -k -$SIGNAL"
}

start() {
	cd "$WORKING_DIRECTORY"

	# Note that the fd 201 of the pid file lock will be inherited by the daemon
	aquire_pid_lock || ok "$APPLICATION_NAME already running (PIDs: `pids`)"
	daemonize "$RUN_USER" "$START_COMMAND" "$LOG_FILE" "$PID_FILE"
	release_pid_lock

	ok "$APPLICATION_NAME running (PIDs: `pids`)"
}

wait_while_pids() {
	local SECONDS="$1"
	while [[ `pids` && $(( SECONDS-- )) != 0 ]]; do
		sleep 1
		echo -n '.'
	done
	[[ $SECONDS == -1 ]] && return 1
	return 0
}

stop() {
	[[ `pids` ]] || ok "$APPLICATION_NAME already stopped"
	echo -n "stopping $APPLICATION_NAME ."

	if [[ "$STOP_COMMAND" ]]; then
		cd "$WORKING_DIRECTORY"
		run_as "$RUN_USER" "${STOP_COMMAND//\%PID/`pid`}"
		wait_while_pids "$STOP_WAIT" && ok " stopped"
	fi

	pids_send_signal TERM
	wait_while_pids "$STOP_WAIT" && ok " terminated"

	if $ALLOW_KILL; then
		pids_send_signal KILL
		wait_while_pids "$STOP_WAIT" && ok " killed"
	fi

	fail " will not stop!" 5
}

# source RedHat startup functions
[[ -x "/etc/rc.d/init.d/functions" ]] && . "/etc/rc.d/init.d/functions"

## Init variables
# source Java conf (JAVA_HOME)
[[ -r "/etc/java/java.conf" ]] && . "/etc/java/java.conf"
export JAVA_HOME

# name of this script
INITD_NAME="`basename $0 | tr ' ' '_'`"

# the name of managed application
[[ "$APPLICATION_NAME" ]] || APPLICATION_NAME="$INITD_NAME"

# lock file for this script
INITD_LOCK="/tmp/java-init-$INITD_NAME.LOCK"

# source test sysconfig if we are testing
[[ -r "test/sysconfig" ]] && . "test/sysconfig"

# source sysconfig variables
[[ -r "/etc/sysconfig/$INITD_NAME" ]] && . "/etc/sysconfig/$INITD_NAME"

## Verify variables
[[ "$WORKING_DIRECTORY" ]] || error "working directory not defined" 2
[[ -d "$WORKING_DIRECTORY" ]] || error "working directory '$WORKING_DIRECTORY' not a directory" 2
[[ "$START_COMMAND" ]] || error "start command not defined" 2
[[ "$LOG_FILE" ]] || error "log file not defined" 2
[[ "$STOP_WAIT" ]] || error "stop wait time not defined" 2
[[ "$ALLOW_KILL" ]] || error "allow kill not defined" 2
[[ "$PID_FILE" ]] || error "PID file not defined" 2

## Execute operation
close_fds

case "$1" in
	start)
		need_initd_lock
		start
	;;
	stop)
		need_initd_lock
		stop
	;;
	restart)
		need_initd_lock
	;;
	status)
		PIDS=`pids`
		if [[ "$PIDS" ]]; then
			echo "$APPLICATION_NAME is running (PIDs: $PIDS)"
			exit 0
		else
			echo "$APPLICATION_NAME is stopped"
			exit 1
		fi
	;;
	threaddump)
		PID=`pid`
		[[ "$PID" ]] || fail "$APPLICATION_NAME is stopped"
		run_as "$RUN_USER" "kill -SIGQUIT '$PID'"
	;;
	*)
		echo "Usage: $INITD_NAME (start|stop|restart|status|threaddump)"
	;;
esac

# vim: set ft=sh sw=4 ts=4 noexpandtab :
