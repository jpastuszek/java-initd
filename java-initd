#!/bin/bash

## Functions

error() {
	echo "$1!" 1>&2
	exit $2
}

ok() {
	if [ -x /etc/rc.d/init.d/functions ]; then
		echo_success
		echo $1
	else
		echo "$1 [  OK  ]"
	fi
	exit $2
}

fail() {
	if [ -x /etc/rc.d/init.d/functions ]; then
		echo_failure
		echo $1
	else
		echo "$1 [  FAILED  ]"
	fi
	exit $2
}

clean_lock() {
	[[ -w "$INITD_LOCK" ]] && rm -f "$INITD_LOCK"
}

lock_initd() {
	[[ -f "$INITD_LOCK" ]] || touch "$INITD_LOCK" || error "connot touch init script lock file '$INITD_LOCK'" 2
	exec 200>>"$INITD_LOCK"
	flock -n 200
}

need_initd_lock() {
	lock_initd || error "script already running" 2
	# clean_lock on termination
	trap "clean_lock" 0 1 2 3 6 9 14 15
}

close_fds() {
	# We close all inherited FDs
	# This is important so we don't hold open file or sockets from calling process
	for I in {3..255}; do eval "exec $I>&-"; done
}

aquire_pid_lock() {
	[[ -f "$PID_FILE" ]] || touch "$PID_FILE" || error "connot touch pid file '$PID_FILE'" 2
	exec 201>>"$PID_FILE"
	flock -n 201
	RET=$?
	[[ $RET > 0 ]] && release_pid_lock
	return $RET
}

release_pid_lock() {
	exec 201<&-
}

run_as() {
	local RUN_USER="$1"
	local COMMAND="$2"

	if [[ "$USER" == "$RUN_USER" || -z "$RUN_USER" ]]; then
		# We're already the $RUN_AS_USER so just exec the script.
		/bin/bash -l -c "$COMMAND"
	else
		COMPLETE_COMMAND="(${NOHUP}$COMPLETE_COMMAND')$STDOUT_REDIR"
		[[ "$USER" == "root" ]] || error "cannot run command '$COMMAND' as user '$RUN_USER': need to be root" 99
		su - $RUN_USER -c "$COMMAND"
	fi
}

daemonize() {
	local RUN_USER="$1"
	local COMMAND="$2"
	local LOG_FILE="$3"
	local PID_FILE="$4"

	# Here we make new process with new session (setsid) and run it with closed STDIN and this init script lock file fd
	run_as "$RUN_USER" "setsid bash -c '( $COMMAND ) 0<&- 200<&- 1>>\"$LOG_FILE\" 2>&1 & eval \"echo \$! > '$PID_FILE'\"'"
}

pids() {
	run_as "$RUN_USER" "fuser /tmp/test.pid 2>/dev/null | sed 's, *,,'"
}

pids_send_signal() {
	local SIGNAL="$1"
	run_as "$RUN_USER" "fuser /tmp/test.pid -s -k -$SIGNAL"
}

start() {
	[[ "$WORKING_DIRECTORY" ]] || error "working directory not defined" 2
	[[ -d "$WORKING_DIRECTORY" ]] || error "working directory '$WORKING_DIRECTORY' not a directory" 2
	cd "$WORKING_DIRECTORY"

	[[ "$START_COMMAND" ]] || error "start command not defined" 2
	[[ "$LOG_FILE" ]] || error "log file not defined" 2

	# Note that the fd 201 of the pid file lock will be inherited by the daemon
	aquire_pid_lock || ok "$INITD_NAME already running (pids: `pids`)"
	daemonize "$RUN_USER" "$START_COMMAND" "$LOG_FILE" "$PID_FILE"
	release_pid_lock

	ok "$INITD_NAME runnig (pids: `pids`)"
}

wait_while_pids() {
	local SECONDS="$1"
	while [[ `pids` && $(( SECONDS-- )) != 0 ]]; do
		sleep 1
		echo -n '.'
	done
	[[ $SECONDS == -1 ]] && return 1
	return 0
}

stop() {
	[[ "$STOP_WAIT" ]] || error "stop wait time not defined" 2
	[[ "$ALLOW_KILL" ]] || error "allow kill not defined" 2

	[[ `pids` ]] || ok "$INITD_NAME already stopped"
	echo -n "stopping $INITD_NAME..."

	pids_send_signal TERM
	wait_while_pids "$STOP_WAIT" && ok " terminated"

	if $ALLOW_KILL; then
		pids_send_signal KILL
		wait_while_pids "$STOP_WAIT" && ok " killed"
	fi

	fail " will not stop!" 5
}

# Source RedHat startup functions
if [ -x /etc/rc.d/init.d/functions ]; then
	  . /etc/rc.d/init.d/functions
fi

## Init variables
INITD_NAME="`basename $0 | tr ' ' '_'`"

# The name of managed application
if [ -z "$APPLICATION_NAME" ]; then
	APPLICATION_NAME="$INITD_NAME"
fi

INITD_LOCK="/tmp/java-init-$INITD_NAME.LOCK"

if [ -e "test/sysconfig" ]; then
	. test/sysconfig
fi

## Prepare variables and env
close_fds

[[ "$PID_FILE" ]] || error "pid file not defined" 2

## Execute operation
case "$1" in
	start)
		need_initd_lock
		start
	;;
	stop)
		need_initd_lock
		stop
	;;
	restart)
		need_initd_lock
	;;
	status)
		PIDS=`pids`
		if [[ "$PIDS" ]]; then
			echo "$INITD_NAME is running (pids: $PIDS)"
			exit 0
		else
			echo "$INITD_NAME is stopped"
			exit 1
		fi
	;;
	*)
		echo "Usage: $INITD_NAME (start|stop|restart|status|threaddump)"
	;;
esac

# vim: set ft=sh sw=4 ts=4 noexpandtab :
